<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>Symbol Live Tx Viewer</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
  body {
    background: #f4f1ff;
    font-family: "Inter","Hiragino Sans","Noto Sans JP",sans-serif;
    margin: 0;
    padding: 0;
  }

  h1 {
    background: linear-gradient(135deg, #6B4DF5, #9d84ff);
    color: white;
    padding: 18px 20px;
    margin: 0;
    font-size: 22px;
    letter-spacing: 0.5px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  }

  #list { padding: 20px; }

  .tx {
    background: #ffffff;
    margin-bottom: 16px;
    padding: 14px 20px 14px 70px;
    border-radius: 14px;
    box-shadow: 0 4px 10px rgba(105, 70, 230, 0.15);
    animation: fadeIn 0.45s ease;
    transition: all 0.35s ease;
    cursor: pointer;
    position: relative;
  }

  .unconfirmed {
    background: #fff7d1 !important;
  }

  .identicon {
    width: 42px;
    height: 42px;
    position: absolute;
    left: 16px;
    top: 14px;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 0 0 3px #ffffffaa;
  }

  .hash {
    font-size: 12px;
    margin-top: 6px;
    color: #6B4DF5;
    opacity: 0.9;
  }

  .time {
    font-size: 12px;
    margin-top: 4px;
    color: #444;
  }

  .tx b { color: #0066ff; }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(14px); }
    to   { opacity: 1; transform: translateY(0); }
  }
</style>
</head>

<body>
<h1>Symbol Live Tx Viewer</h1>
<div id="list"></div>

<script>
/* ===== Ë®≠ÂÆö ===== */
const NODES = [
  "https://testnet1.symbol-mikun.net:3001",
  "https://sym-test-01.opening-line.jp:3001"
];

const ADDRESS = "TANWG4F32RMJT6UEKA2COQPJERCDLHB34RIGBII";

/* „ÉÜ„Çπ„Éà„Éç„ÉÉ„Éà epochAdjustment */
const epochAdjustment = 1667250467;

let ws = null;
let uid = "";
const callbacks = {};
const txMap = {};

/* ============================================================
   Symbol timestamp ‚Üí ‰∫∫Èñì„ÅÆÊôÇÈñì„Å∏
   ============================================================ */
function formatTimestamp(ts) {
  if (!ts) return "";
  const sec = epochAdjustment + (Number(ts) / 1000);
  return new Date(sec * 1000).toLocaleString("ja-JP", { hour12: false });
}

/* ============================================================
   Identicon
   ============================================================ */
function identiconSvg(address) {
  let hash = [];
  for (let i = 0; i < address.length; i++) {
    hash.push(address.charCodeAt(i) & 0xff);
  }
  while (hash.length < 15) hash.push(0);

  const hue = hash[0] % 360;
  let svg = `<svg width="42" height="42" viewBox="0 0 5 5" xmlns="http://www.w3.org/2000/svg">`;

  for (let y = 0; y < 5; y++) {
    for (let x = 0; x < 3; x++) {
      const i = (x + y * 3) % hash.length;
      if (hash[i] & 1) {
        const color = `hsl(${hue},70%,55%)`;
        svg += `<rect x="${x}" y="${y}" width="1" height="1" fill="${color}"/>`;
        svg += `<rect x="${4-x}" y="${y}" width="1" height="1" fill="${color}"/>`;
      }
    }
  }
  svg += `</svg>`;

  return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
}

/* ============================================================
   „É°„ÉÉ„Çª„Éº„Ç∏Âæ©Âè∑
   ============================================================ */
function decodeMessage(payload) {
  if (!payload) return "(no message)";
  let hex = payload;
  if (hex.startsWith("00")) hex = hex.slice(2);
  const arr = hex.match(/.{1,2}/g);
  if (!arr) return "(decode error)";
  const bytes = new Uint8Array(arr.map(h => parseInt(h, 16)));
  try { return new TextDecoder("utf-8").decode(bytes); }
  catch { return "(decode error)"; }
}

/* ============================================================
   „Éñ„É≠„ÉÉ„ÇØ„ÅÆ timestamp „Çí REST „Åã„ÇâÂèñÂæó
   ============================================================ */
async function getBlockTimestamp(height) {
  try {
    const NODE = NODES[Math.floor(Math.random() * NODES.length)];
    const res = await fetch(`${NODE}/blocks/${height}`);
    const json = await res.json();
    return json.block.timestamp;
  } catch (e) {
    console.error("Block fetch error:", e);
    return null;
  }
}

/* ============================================================
   „Ç´„Éº„ÉâÁîüÊàê
   ============================================================ */
function createTxElement(hash, msg, state, sender, timestamp) {
  const div = document.createElement("div");
  div.className = `tx ${state}`;
  div.id = hash;

  const icon = document.createElement("img");
  icon.className = "identicon";
  icon.src = identiconSvg(sender);
  div.appendChild(icon);

  const msgEl = document.createElement("b");
  msgEl.textContent = msg;
  div.appendChild(msgEl);

  const hashEl = document.createElement("div");
  hashEl.className = "hash";
  hashEl.textContent = `${state.toUpperCase()} - ${hash}`;
  div.appendChild(hashEl);

  if (state === "confirmed" && timestamp) {
    const timeEl = document.createElement("div");
    timeEl.className = "time";
    timeEl.textContent = "üïí " + formatTimestamp(timestamp);
    div.appendChild(timeEl);
  }

  div.onclick = () =>
    window.open(`https://testnet.symbol.fyi/transactions/${hash}`, "_blank");

  document.getElementById("list").prepend(div);
  txMap[hash] = div;
}

/* ============================================================
   Êú™ÊâøË™ç ‚Üí ÊâøË™ç „ÅÆÊòáÊ†ºÂá¶ÁêÜ
   ============================================================ */
function promote(hash, timestamp) {
  const el = txMap[hash];
  if (!el) return;

  el.classList.remove("unconfirmed");
  el.classList.add("confirmed");

  const hashEl = el.querySelector(".hash");
  hashEl.textContent = `CONFIRMED - ${hash}`;

  if (!el.querySelector(".time") && timestamp) {
    const timeDiv = document.createElement("div");
    timeDiv.className = "time";
    timeDiv.textContent = "üïí " + formatTimestamp(timestamp);
    el.appendChild(timeDiv);
  }
}

/* ============================================================
   ÈÅéÂéªÂ±•Ê≠¥Ë™≠„ÅøËæº„ÅøÔºàRESTÔºâ
   ============================================================ */
async function loadHistory() {
  const NODE = NODES[Math.floor(Math.random() * NODES.length)];
  const url = `${NODE}/transactions/confirmed?address=${ADDRESS}&pageSize=100&order=desc`;

  try {
    const res = await fetch(url);
    const json = await res.json();
    const txs = json.data || [];
    txs.reverse().forEach(item => {
      const hash = item.meta.hash;
      if (txMap[hash]) return;

      createTxElement(
        hash,
        decodeMessage(item.transaction.message),
        "confirmed",
        item.transaction.signerPublicKey,
        item.meta.timestamp
      );
    });
  } catch (e) {
    console.error("History load failed:", e);
  }
}

/* ============================================================
   WebSocket Êé•Á∂ö
   ============================================================ */
async function connectWS() {
  const NODE = NODES[Math.floor(Math.random() * NODES.length)];
  const WSURL = NODE.replace("http", "ws") + "/ws";

  ws = new WebSocket(WSURL);
  ws.onopen = () => console.log("WS Connected:", WSURL);

  ws.onmessage = (e) => {
    const data = JSON.parse(e.data);

    if (data.uid !== undefined) {
      uid = data.uid;
      subscribe("block");
      subscribe(`unconfirmedAdded/${ADDRESS}`);
      subscribe(`confirmedAdded/${ADDRESS}`);
      return;
    }

    if (callbacks[data.topic]) {
      callbacks[data.topic].forEach(cb => cb(data));
    }
  };

  ws.onerror = (e) => console.error("WS Error:", e);
  ws.onclose = () => setTimeout(connectWS, 2000);
}

function subscribe(topic) {
  ws.send(JSON.stringify({ uid, subscribe: topic }));
}

/* ============================================================
   „Ç≥„Éº„É´„Éê„ÉÉ„ÇØÁôªÈå≤
   ============================================================ */
function addCallback(topic, cb) {
  if (!callbacks[topic]) callbacks[topic] = [];
  callbacks[topic].push(cb);
}

/* ============================================================
   Êú™ÊâøË™ç
   ============================================================ */
addCallback(`unconfirmedAdded/${ADDRESS}`, payload => {
  const tx = payload.data;
  createTxElement(
    tx.meta.hash,
    decodeMessage(tx.transaction.message),
    "unconfirmed",
    tx.transaction.signerPublicKey,
    null
  );
});

/* ============================================================
   ÊâøË™çÔºàheight ‚Üí timestampÔºâ
   ============================================================ */
addCallback(`confirmedAdded/${ADDRESS}`, async payload => {
  const tx = payload.data;

  const hash = tx.meta.hash;
  const height = tx.meta.height;
  const sender = tx.transaction.signerPublicKey;
  const msg = decodeMessage(tx.transaction.message);

  const blockTimestamp = await getBlockTimestamp(height);

  if (!txMap[hash]) {
    createTxElement(hash, msg, "confirmed", sender, blockTimestamp);
  } else {
    promote(hash, blockTimestamp);
  }
});

/* ============================================================
   „Éñ„É≠„ÉÉ„ÇØ
   ============================================================ */
addCallback("block", payload =>
  console.log("‚õì Block:", payload.data.block.height)
);

/* ============================================================
   ÂàùÊúü„É≠„Éº„Éâ
   ============================================================ */
(async () => {
  await loadHistory();
  connectWS();
})();
</script>
</body>
</html>
