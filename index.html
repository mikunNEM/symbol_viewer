<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>Symbol Live Tx Viewer (Identicon)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
  body {
    background: #f4f1ff;
    font-family: "Inter","Hiragino Sans","Noto Sans JP",sans-serif;
    margin: 0;
    padding: 0;
  }

  h1 {
    background: linear-gradient(135deg, #6B4DF5, #9d84ff);
    color: white;
    padding: 18px 20px;
    margin: 0;
    font-size: 22px;
    letter-spacing: 0.5px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  }

  #list {
    padding: 20px;
  }

  .tx {
    background: #ffffff;
    margin-bottom: 16px;
    padding: 14px 20px 14px 70px; /* Â∑¶„Å´„Ç¢„Ç§„Ç≥„É≥ÂàÜ„ÅÆ‰ΩôÁôΩ */
    border-radius: 14px;
    box-shadow: 0 4px 10px rgba(105, 70, 230, 0.15);
    animation: fadeIn 0.45s ease;
    transition: all 0.35s ease;
    cursor: pointer;
    position: relative;
  }

  /* Unconfirmed is yellow */
  .unconfirmed {
    background: #fff7d1 !important;
  }

  /* identicon container */
  .identicon {
    width: 42px;
    height: 42px;
    position: absolute;
    left: 16px;
    top: 14px;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 0 0 3px #ffffffaa;
  }

  .hash {
    font-size: 12px;
    margin-top: 6px;
    color: #6B4DF5;
    opacity: 0.9;
  }

  .tx b {
  color: #0066ff;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(14px); }
    to   { opacity: 1; transform: translateY(0); }
  }
</style>
</head>

<body>
<h1>Symbol Live Tx Viewer</h1>
<div id="list"></div>

<script>
/* ===== Ë®≠ÂÆö ===== */
const NODES = [
  "https://testnet1.symbol-mikun.net:3001",
  "https://sym-test-01.opening-line.jp:3001"
];

const ADDRESS = "TANWG4F32RMJT6UEKA2COQPJERCDLHB34RIGBII";

let ws = null;
let uid = "";
const callbacks = {};
const txMap = {};

/* ============================================================
   üß© Blockies Identicon GeneratorÔºàGitHubÈ¢®Ôºâ
   ============================================================ */
function identiconSvg(address) {
  // Hash ‚Üí 15 bytes
  let hash = [];
  for (let i = 0; i < address.length; i++) {
    hash.push(address.charCodeAt(i) & 0xff);
  }
  while (hash.length < 15) hash.push(0);

  // Hue from first byte
  const hue = hash[0] % 360;

  // 5√ó5 grid
  let svg = `<svg width="42" height="42" viewBox="0 0 5 5" xmlns="http://www.w3.org/2000/svg">`;

  for (let y = 0; y < 5; y++) {
    for (let x = 0; x < 3; x++) {
      const i = (x + y * 3) % hash.length;
      const bit = hash[i] & 1;

      if (bit === 1) {
        const color = `hsl(${hue},70%,55%)`;
        svg += `<rect x="${x}" y="${y}" width="1" height="1" fill="${color}"/>`;
        svg += `<rect x="${4-x}" y="${y}" width="1" height="1" fill="${color}"/>`;
      }
    }
  }

  svg += `</svg>`;
  return "data:image/svg+xml;base64," + btoa(svg);
}

/* ============================================================
   decodeMessage()
   ============================================================ */
function decodeMessage(payload) {
  if (!payload || typeof payload !== "string") return "(no message)";
  let hex = payload;
  if (hex.startsWith("00")) hex = hex.slice(2);

  const arr = hex.match(/.{1,2}/g);
  if (!arr) return "(decode error)";
  const bytes = new Uint8Array(arr.map(h => parseInt(h, 16)));

  try { return new TextDecoder("utf-8").decode(bytes); }
  catch { return "(decode error)"; }
}

/* ============================================================
   üé® UI: „Ç´„Éº„ÉâÁîüÊàêÔºàIdenticon‰ªò„ÅçÔºâ
   ============================================================ */
function createTxElement(hash, msg, state, sender) {
  const div = document.createElement("div");
  div.className = `tx ${state}`;
  div.id = hash;

  /* Identicon */
  const icon = document.createElement("img");
  icon.className = "identicon";
  icon.src = identiconSvg(sender);
  div.appendChild(icon);

  div.innerHTML += `
    <b>${msg}</b>
    <div class="hash">${state.toUpperCase()} - ${hash}</div>
  `;

  div.onclick = () =>
    window.open(`https://testnet.symbol.fyi/transactions/${hash}`, "_blank");

  document.getElementById("list").prepend(div);
  txMap[hash] = div;
}

function promote(hash) {
  const el = txMap[hash];
  if (!el) return;
  el.classList.remove("unconfirmed");
  el.classList.add("confirmed");
  el.querySelector(".hash").textContent = `CONFIRMED - ${hash}`;
}

/* ============================================================
   ÈÅéÂéªÂ±•Ê≠¥Ë™≠„ÅøËæº„Åø
   ============================================================ */
async function loadHistory() {
  const NODE = NODES[Math.floor(Math.random() * NODES.length)];
  const url =
    `${NODE}/transactions/confirmed?address=${ADDRESS}&pageSize=30&order=desc`;

  try {
    const res = await fetch(url);
    const json = await res.json();
    const txs = json.data || [];

    txs.reverse().forEach(item => {
      const hash = item.meta.hash;
      if (txMap[hash]) return;

      const msg = decodeMessage(item.transaction.message);
      const sender = item.transaction.signerPublicKey;

      createTxElement(hash, msg, "confirmed", sender);
    });

  } catch (e) {
    console.error("History load failed:", e);
  }
}

/* ============================================================
   WebSocket Ê∞∏Á∂öÊé•Á∂ö
   ============================================================ */
async function connectWS() {
  const NODE = NODES[Math.floor(Math.random() * NODES.length)];
  const WSURL = NODE.replace("http", "ws") + "/ws";

  ws = new WebSocket(WSURL);

  ws.onopen = () => console.log("WS Connected:", WSURL);

  ws.onmessage = (e) => {
    const data = JSON.parse(e.data);

    if (data.uid !== undefined) {
      uid = data.uid;
      subscribe("block");
      subscribe(`unconfirmedAdded/${ADDRESS}`);
      subscribe(`confirmedAdded/${ADDRESS}`);
      return;
    }

    if (callbacks[data.topic]) {
      callbacks[data.topic].forEach(cb => cb(data.data));
    }
  };

  ws.onerror = (e) => console.error("WS Error:", e);
  ws.onclose = () => {
    uid = "";
    setTimeout(connectWS, 2000);
  };
}

function subscribe(topic) {
  ws.send(JSON.stringify({ uid, subscribe: topic }));
}

/* ============================================================
   WebSocket „Ç§„Éô„É≥„ÉàÁôªÈå≤
   ============================================================ */
function addCallback(topic, cb) {
  if (!callbacks[topic]) callbacks[topic] = [];
  callbacks[topic].push(cb);
}

addCallback(`unconfirmedAdded/${ADDRESS}`, tx => {
  const hash = tx.meta.hash;
  const msg = decodeMessage(tx.transaction.message);
  const sender = tx.transaction.signerPublicKey;

  createTxElement(hash, msg, "unconfirmed", sender);
});

addCallback(`confirmedAdded/${ADDRESS}`, tx => {
  const hash = tx.meta.hash;
  const sender = tx.transaction.signerPublicKey;

  if (!txMap[hash]) {
    const msg = decodeMessage(tx.transaction.message);
    createTxElement(hash, msg, "confirmed", sender);
  } else {
    promote(hash);
  }
});

addCallback("block", block =>
  console.log("‚õì Block:", block.block.height)
);

/* ============================================================
   ÂàùÊúü„É≠„Éº„Éâ
   ============================================================ */
(async () => {
  await loadHistory();
  connectWS();
})();
</script>
</body>
</html>
